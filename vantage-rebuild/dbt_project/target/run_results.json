{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.0", "generated_at": "2026-01-31T00:20:36.044072Z", "invocation_id": "98c121f9-b234-4714-8cf1-4f7d7eda6dcb", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.605132Z", "completed_at": "2026-01-31T00:20:35.609407Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.609640Z", "completed_at": "2026-01-31T00:20:35.683825Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.08074116706848145, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.dim_calendar", "compiled": true, "compiled_code": "with recursive date_series as (\n    select cast('2024-01-01' as date) as date_day\n    union all\n    select date_day + interval 1 day\n    from date_series\n    where date_day < '2024-12-31'\n),\n\nfinal as (\n    select\n        date_day as date_key,\n        extract(year from date_day) as year,\n        extract(month from date_day) as month_num,\n        monthname(date_day) as month_name,\n        week(date_day) as iso_week,\n        dayofweek(date_day) as day_of_week_num, -- 0=Sun in some DBs, DuckDB: 0=Sun? No, DuckDB ISODOW is 1=Mon. dayofweek 0=Sun.\n        case when dayofweek(date_day) in (0, 6) then true else false end as is_weekend\n    from date_series\n)\n\nselect * from final", "relation_name": "\"vantage\".\"main\".\"dim_calendar\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.687500Z", "completed_at": "2026-01-31T00:20:35.689862Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.690058Z", "completed_at": "2026-01-31T00:20:35.710055Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.023163318634033203, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.stg_budget", "compiled": true, "compiled_code": "with source as (\n    select * from \"vantage\".\"main\".\"raw_budget\"\n),\n\nrenamed as (\n    select\n        cast(month as date) as budget_month,\n        shop_id,\n        currency as currency_code,\n        budget_revenue,\n        -- Generate MD5 key for unique identification if needed in future, though (month, shop) is unique\n        concat(shop_id, '-', cast(month as varchar)) as budget_id\n    from source\n)\n\nselect * from renamed", "relation_name": "\"vantage\".\"main\".\"stg_budget\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.712126Z", "completed_at": "2026-01-31T00:20:35.714025Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.714296Z", "completed_at": "2026-01-31T00:20:35.728798Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.017499923706054688, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.stg_line_items", "compiled": true, "compiled_code": "with source as (\n    select * from \"vantage\".\"main\".\"raw_line_items\"\n),\n\nrenamed as (\n    select\n        line_id as line_item_id,\n        order_id,\n        sku_id,\n        qty as quantity,\n        unit_price_paid as unit_price_local,\n        unit_cost as unit_cost_local,\n        is_returned\n    from source\n)\n\nselect * from renamed", "relation_name": "\"vantage\".\"main\".\"stg_line_items\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.731324Z", "completed_at": "2026-01-31T00:20:35.732975Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.733337Z", "completed_at": "2026-01-31T00:20:35.754178Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.02350902557373047, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.stg_marketing", "compiled": true, "compiled_code": "with source as (\n    select * from \"vantage\".\"main\".\"raw_marketing_daily\"\n),\n\nrenamed as (\n    select\n        cast(date as date) as date_day,\n        shop_id,\n        spend_amount as marketing_spend_local,\n        currency as currency_code\n    from source\n)\n\nselect * from renamed", "relation_name": "\"vantage\".\"main\".\"stg_marketing\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.756199Z", "completed_at": "2026-01-31T00:20:35.758080Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.758262Z", "completed_at": "2026-01-31T00:20:35.774182Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01862502098083496, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.stg_orders", "compiled": true, "compiled_code": "with source as (\n    select * from \"vantage\".\"main\".\"raw_orders\"\n),\n\nrenamed as (\n    select\n        order_id,\n        customer_id,\n        shop_id,\n        -- Correct datatypes\n        cast(order_date as date) as order_date,\n        currency_code\n    from source\n)\n\nselect * from renamed", "relation_name": "\"vantage\".\"main\".\"stg_orders\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.776759Z", "completed_at": "2026-01-31T00:20:35.778833Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.779014Z", "completed_at": "2026-01-31T00:20:35.797672Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.022639989852905273, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.stg_products", "compiled": true, "compiled_code": "with source as (\n    select * from \"vantage\".\"main\".\"raw_products\"\n),\n\nrenamed as (\n    select\n        sku_id,\n        category,\n        product_name,\n        avg_price_eur as list_price_eur,\n        unit_cost_eur,\n        popularity_score\n    from source\n)\n\nselect * from renamed", "relation_name": "\"vantage\".\"main\".\"stg_products\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.800783Z", "completed_at": "2026-01-31T00:20:35.800785Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.801154Z", "completed_at": "2026-01-31T00:20:35.855003Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.05485987663269043, "adapter_response": {"_message": "INSERT 366", "code": "INSERT", "rows_affected": 366}, "message": "INSERT 366", "failures": null, "unique_id": "seed.vantage_rebuild.exchange_rates", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.856785Z", "completed_at": "2026-01-31T00:20:35.858493Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.858656Z", "completed_at": "2026-01-31T00:20:35.890911Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.03469204902648926, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.fct_budget_daily", "compiled": true, "compiled_code": "with budget as (\n    select * from \"vantage\".\"main\".\"stg_budget\"\n),\n\n-- Generate Daily Budget (Linear Split)\n-- We need a date spine, but for MVP we can fan out by joining to a calendar or just dividing by 30\n-- Ideally use dbt_utils.date_spine.\n-- Hack for MVP: Just keep it Monthly? No, spec says Daily.\n-- We will assume 30 days per month for simplicity here to avoid massive join complexity without a calendar source.\n-- BETTER: Use recursive CTE to generate days.\n\ndates as (\n    -- Recursively generate days for 2024\n    with recursive date_series as (\n        select cast('2024-01-01' as date) as date_day\n        union all\n        select date_day + interval 1 day\n        from date_series\n        where date_day < '2024-12-31'\n    )\n    select * from date_series\n),\n\nfinal as (\n    select\n        d.date_day,\n        b.shop_id,\n        b.currency_code,\n        -- Simple allocation: Monthly Budget / Days in Month\n        b.budget_revenue / extract(day from last_day(d.date_day)) as daily_budget_revenue\n    from budget b\n    inner join dates d \n        on extract(month from d.date_day) = extract(month from b.budget_month)\n        and extract(year from d.date_day) = extract(year from b.budget_month)\n)\n\nselect * from final", "relation_name": "\"vantage\".\"main\".\"fct_budget_daily\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.895117Z", "completed_at": "2026-01-31T00:20:35.896445Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.896602Z", "completed_at": "2026-01-31T00:20:35.911493Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.016927242279052734, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.dim_products", "compiled": true, "compiled_code": "with products as (\n    select * from \"vantage\".\"main\".\"stg_products\"\n)\n\nselect\n    sku_id,\n    product_name,\n    category,\n    -- Simple tiers based on price/category\n    case \n        when category = 'Ausr\u00fcstung' then 'Hardware'\n        when category = 'Schuhe' then 'Footwear'\n        else 'Apparel'\n    end as business_unit,\n    list_price_eur\nfrom products", "relation_name": "\"vantage\".\"main\".\"dim_products\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:35.936841Z", "completed_at": "2026-01-31T00:20:35.945175Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:35.945360Z", "completed_at": "2026-01-31T00:20:36.016958Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.08077430725097656, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.vantage_rebuild.fct_transactions", "compiled": true, "compiled_code": "with  __dbt__cte__int_exchange_rates as (\nwith rate_source as (\n    select * from \"vantage\".\"main\".\"exchange_rates\"\n),\n\nfinal as (\n    select\n        date_day,\n        from_currency,\n        to_currency,\n        rate\n    from rate_source\n    -- We assume only 'to_currency' = EUR matters for now\n    where to_currency = 'EUR'\n)\n\nselect * from final\n),  __dbt__cte__int_orders_standardized as (\nwith orders as (\n    select * from \"vantage\".\"main\".\"stg_orders\"\n),\n\nline_items as (\n    select * from \"vantage\".\"main\".\"stg_line_items\"\n),\n\nrates as (\n    select * from __dbt__cte__int_exchange_rates\n),\n\n-- Join all together\njoined as (\n    select\n        l.line_item_id,\n        l.order_id,\n        o.shop_id,\n        o.customer_id,\n        o.order_date,\n        o.currency_code,\n        l.sku_id,\n        l.quantity,\n        l.unit_price_local,\n        l.unit_cost_local,\n        l.is_returned,\n        \n        -- Exchange Rate Lookup\n        -- If currency is EUR, rate is 1.0. If not, join to rates.\n        coalesce(r.rate, 1.0) as exchange_rate\n\n    from line_items l\n    left join orders o on l.order_id = o.order_id\n    left join rates r \n        on o.order_date = r.date_day \n        and o.currency_code = r.from_currency\n        and r.to_currency = 'EUR'\n),\n\ncalculated as (\n    select\n        *,\n        -- Monetary conversions\n        unit_price_local * exchange_rate as unit_price_eur,\n        unit_cost_local * exchange_rate as unit_cost_eur,\n        \n        -- Line Totals\n        (unit_price_local * exchange_rate) * quantity as gross_revenue_eur,\n        (unit_cost_local * exchange_rate) * quantity as cogs_eur\n        \n    from joined\n)\n\nselect * from calculated\n),  __dbt__cte__int_marketing_allocated as (\nwith orders_std as (\n    select * from __dbt__cte__int_orders_standardized\n),\n\nmarketing_daily as (\n    select * from \"vantage\".\"main\".\"stg_marketing\"\n),\n\n-- 1. Daily Sales Summary (Dominator for allocation)\ndaily_sales as (\n    select\n        order_date,\n        shop_id,\n        sum(gross_revenue_eur) as total_daily_revenue_eur\n    from orders_std\n    group by 1, 2\n),\n\n-- 2. Daily Spend (Numerator)\ndaily_spend as (\n    select\n        date_day,\n        shop_id,\n        -- Assume marketing spend in stg is already standardized or matches shop currency\n        -- If shop_id=CH, marketing is likely in CHF. We should convert it to EUR too if generating strictly in EUR.\n        -- Usage: For simplicity, let's assume raw_marketing_daily is in EUR or close enough for this MVP \n        -- (Since shop_id=CH has base currency CHF, but marketing might be global). \n        -- Actually, generator output has 'currency' col.\n        marketing_spend_local\n    from marketing_daily\n),\n\n-- 3. Allocation Factor\nallocation_factors as (\n    select\n        ds.order_date,\n        ds.shop_id,\n        ds.total_daily_revenue_eur,\n        msp.marketing_spend_local as daily_marketing_spend,\n        -- Avoid divide by zero\n        case \n            when ds.total_daily_revenue_eur > 0 \n            then msp.marketing_spend_local / ds.total_daily_revenue_eur \n            else 0 \n        end as cost_per_eur_revenue\n    from daily_sales ds\n    inner join daily_spend msp \n        on ds.order_date = msp.date_day \n        and ds.shop_id = msp.shop_id\n),\n\n-- 4. Apply to Lines\nfinal_allocation as (\n    select\n        ord.line_item_id,\n        ord.order_id,\n        ord.order_date,\n        ord.shop_id,\n        ord.customer_id,\n        ord.sku_id,\n        ord.quantity,\n        ord.unit_price_local,\n        ord.unit_cost_local,\n        ord.gross_revenue_eur,\n        af.cost_per_eur_revenue,\n        \n        -- Allocated Cost\n        ord.gross_revenue_eur * af.cost_per_eur_revenue as marketing_cost_allocated_eur\n        \n    from orders_std ord\n    left join allocation_factors af \n        on ord.order_date = af.order_date \n        and ord.shop_id = af.shop_id\n)\n\nselect * from final_allocation\n),  __dbt__cte__int_logistics_costs as (\nwith orders as (\n    select * from \"vantage\".\"main\".\"stg_orders\"\n),\n\nline_items as (\n    select * from \"vantage\".\"main\".\"stg_line_items\"\n),\n\n-- Aggregate items per order\norder_stats as (\n    select\n        order_id,\n        count(*) as item_count\n    from line_items\n    group by 1\n),\n\njoined as (\n    select\n        o.order_id,\n        o.shop_id,\n        s.item_count\n    from orders o\n    left join order_stats s on o.order_id = s.order_id\n),\n\n-- Rule Engine for Logistics\ncalculated as (\n    select\n        order_id,\n        shop_id,\n        item_count,\n        -- Rule: Base 3.50 EUR (8.50 CH) + 0.50 per item\n        case\n            when shop_id = 'CH' then 8.50 + (item_count * 0.50)\n            else 3.50 + (item_count * 0.50)\n        end as logistics_cost_eur\n    from joined\n)\n\nselect * from calculated\n), orders_allocated as (\n    select * from __dbt__cte__int_marketing_allocated\n),\n\nlogistics as (\n    select * from __dbt__cte__int_logistics_costs\n),\n\nfinal as (\n    select\n        -- Keys\n        oa.order_id,\n        oa.line_item_id,\n        \n        -- Dimensions\n        cast(oa.order_date as date) as date_key,\n        oa.shop_id as shop_key,\n        oa.customer_id as customer_key,\n        oa.sku_id as product_key,\n        \n        -- Metrics\n        oa.quantity,\n        oa.gross_revenue_eur,\n        \n        -- Costs\n        -- COGS\n        oa.gross_revenue_eur * (oa.unit_cost_local / oa.unit_price_local) as cogs_eur, \n        -- (Doing Ratio calc to be safe on currency, or just use unit_cost_eur column if I had it exposed... \n        -- Wait, int_orders_standardized calculates cogs_eur. \n        -- But int_marketing_allocated only selects a few cols! \n        -- I should update int_marketing_allocated to select * or join back.)\n        \n        -- Let's assume standard joins back to `int_orders_standardized` for cleanliness, \n        -- OR update `int_marketing_allocated` to pass through everything.\n        -- Looking at `int_marketing_allocated.sql`, it selects specific cols. \n        -- I will join back to `int_orders_standardized` here.\n        \n        orders_std.cogs_eur,\n        \n        -- Logistics (Allocated by Item Count weighting)\n        -- Logic: Total Order Logistics Cost / Total Items in Order\n        (l.logistics_cost_eur / l.item_count) as logistics_allocated_eur,\n        \n        -- Marketing (Already allocated)\n        oa.marketing_cost_allocated_eur,\n        \n        -- Margin\n        oa.gross_revenue_eur \n            - orders_std.cogs_eur \n            - (l.logistics_cost_eur / l.item_count)\n            - oa.marketing_cost_allocated_eur \n        as contribution_margin_eur,\n        \n        orders_std.is_returned\n\n    from orders_allocated oa\n    \n    -- Join back to Standardized for COGS/Attributes\n    left join __dbt__cte__int_orders_standardized orders_std \n        using (line_item_id)\n        \n    -- Join Logistics\n    left join logistics l \n        on oa.order_id = l.order_id\n)\n\nselect * from final", "relation_name": "\"vantage\".\"main\".\"fct_transactions\""}, {"status": "pass", "timing": [{"name": "compile", "started_at": "2026-01-31T00:20:36.020487Z", "completed_at": "2026-01-31T00:20:36.022543Z"}, {"name": "execute", "started_at": "2026-01-31T00:20:36.022731Z", "completed_at": "2026-01-31T00:20:36.040183Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.020958900451660156, "adapter_response": {"_message": "OK"}, "message": null, "failures": 0, "unique_id": "test.vantage_rebuild.assert_marketing_fully_allocated", "compiled": true, "compiled_code": "-- assert_marketing_fully_allocated.sql\nwith source as (\n    select sum(marketing_spend_local) as total_spend\n    from \"vantage\".\"main\".\"stg_marketing\"\n    -- Convert to EUR if mixed currencies? For MVP we assume input was normalized or single currency per shop.\n    -- Generator output had 'EUR' for DE/AT and 'CHF' for CH.\n    -- Wait, if CH spend is CHF, and we allocated based on EUR revenue...\n    -- The `int_marketing_allocated` took `marketing_spend_local / total_daily_revenue_eur`.\n    -- This implies we treated local spend as EUR! (Which is a bug if spend was CHF).\n    -- However, for the TEST, we just want to ensure the Distribution Math worked (i.e. we didn't lose money in rounding).\n    -- So we compare Sum(Spend) vs Sum(Allocated).\n),\n\nfact as (\n    select sum(marketing_cost_allocated_eur) as total_allocated\n    from \"vantage\".\"main\".\"fct_transactions\"\n)\n\nselect * \nfrom source, fact\nwhere abs(source.total_spend - fact.total_allocated) > 5.0 \n-- Allow 5 EUR tolerance for rounding errors across 365 days", "relation_name": null}], "elapsed_time": 0.5976729393005371, "args": {"partial_parse": true, "which": "build", "log_level_file": "debug", "select": [], "populate_cache": true, "send_anonymous_usage_stats": true, "static_parser": true, "log_format": "default", "use_colors": true, "version_check": true, "invocation_command": "dbt build", "vars": {}, "warn_error_options": {"include": [], "exclude": []}, "profiles_dir": "/Users/admin/Desktop/BI Pipeline/vantage-rebuild/dbt_project", "log_file_max_bytes": 10485760, "enable_legacy_logger": false, "exclude_resource_types": [], "log_format_file": "debug", "print": true, "printer_width": 80, "write_json": true, "source_freshness_run_project_hooks": false, "export_saved_queries": false, "empty": false, "show": false, "favor_state": false, "use_colors_file": true, "log_level": "info", "quiet": false, "macro_debugging": false, "partial_parse_file_diff": true, "defer": false, "require_resource_names_without_spaces": false, "log_path": "/Users/admin/Desktop/BI Pipeline/vantage-rebuild/dbt_project/logs", "include_saved_query": false, "introspect": true, "show_resource_report": false, "project_dir": "/Users/admin/Desktop/BI Pipeline/vantage-rebuild/dbt_project", "require_explicit_package_overrides_for_builtin_materializations": true, "resource_types": [], "cache_selected_only": false, "indirect_selection": "eager", "exclude": [], "strict_mode": false}}